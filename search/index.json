[{"content":"当编程像对话一样简单：一个改变我开发方式的神奇工具 Cursor是啥 其实就是一个集成到你IDE里面的AI工具\n可以让弱基础小白快速上手代码（据说有人已经实现通过Cursor编程 上线什么小猫补光灯等产品赚米了）\n讲点干货- 为啥好用 因为要钱的肯定比不要钱的好用 下面VSCode有的我就直接用Vscode演示了\nDemo演示 比如这样一个Python的UI界面，还有相关的API调用，我全部都是拿Cursor实现的，我基本没有写代码\n甚至于说当时很复杂的需要参考的阿里云的代码，都是他帮我代劳的（甚至于我自己都没看到的文档，他帮我看到了并且想办法帮我用OSS存储来上传文件） 一些尝试- 王浩宸\nhttps://help.aliyun.com/zh/document-mind/developer-reference/sdk-for-python-user-guide?spm=a2c4g.11186623.help-menu-445637.d_3_0_1_5.32b32384OTkq3p\nhttps://help.aliyun.com/zh/document-mind/developer-reference/convertimagetoexcel?spm=a2c4g.11186623.help-menu-445637.d_3_0_0_2_3.39757051uwNEnn\nhttps://help.aliyun.com/zh/document-mind/developer-reference/sdk-for-python-user-guide?spm=a2c4g.11186623.help-menu-445637.d_3_0_1_5.5e7a104e50dTrl\u0026amp;scm=20140722.H_455184._.OR_help-T_cn~zh-V_1\nhttps://help.aliyun.com/zh/oss/getting-started/get-started-with-oss?spm=a2c4g.11186623.help-menu-31815.d_1_0.3a8631c1gRr796\n模型选择 其实可以说很多了，这点应该是超过Trae和Coplit的 Tab 补全 不过这个Coplit也有，就不多说了 直接帮你改代码-Compose功能 可以帮你 直接改代码（不过目前Coplit也有对应的功能，但是据说效果不好？） 可能一部分原因是他用的模型垃圾，在一部分可能确实做的不太好，毕竟只是插件 他甚至可以直接把你终端的报错给扔上去 Bug-Finder 没试过，但是据说比较费次数 CodeBase-自动识别所有的项目文件 这个是视频里面最推崇的做法\n他会这么做\nAI会根据我们的提示词，查找与指令相关的文件或者是代码块 重新排序：然后对收集到的代码排序，越相关的越靠前 推理 然后最后生成回应 所以要经常引用CodeBase 理论他会把你的数据上传到OpenAI上（应该是这个意思）做一个远程数据库检测 他会检查gitignore，这样就可以防止秘钥等问题上传泄漏的问题 如果没有，你也可以新建.cursorignore来做忽略，这样就可以减少被索引的文件信息量，从而提高检索效率/避免数据泄露 演示 Doc-自动爬虫读参考文献 使用@doc功能，自动帮你去读网页下的参考文献（参考上图） web @web可以联网搜索，这个也是Trae和Coplit没有的\n自动git提交 这个没用过，但是可以帮帮你自动生成git的提交信息 NotePad 这个东西可以做一个临时的记事本 注意Chat和Composer是不互通的，可以利用这个来做一个解决(存储对话记录) 也可以用来记录一些待办事项 CursorRule 对于某一个项目文件，我们可以生成一个cursorrules的文件只针对这个项目的规则 由于.cursorrules需要针对特定项目进行撰写（一般会涉及技术栈的选择），这就引发一个问题，大多cursor初学者，尤其是零编码基础的小伙伴根本就不知道怎么选择技术栈，所以入门阶段就很难写好一份.cursorrules。那怎么办？有两种方法：\n第一种是先不写.cursorrules，直接开干，这就是最开始提到的“先下场干，把手弄脏”的心态。因为对于一些相对简单的项目，有无cursorrules其实差别不会很大，顶多就是中间绕个弯路，最后还是能搞定项目的。\n第二种是把一些.cursorrules范例丢给ai，让ai让帮我们写一份合格的.cursorrules。\ncursor directory：https://cursor.directory/ awesome cursorrules：https://github.com/PatrickJS/aw 一些技巧 先保存再Accept 先跑一下看看能不能work再说 回滚 Cursor会对每次回答做一个Checkpoint，我们可以做回滚、甚至重新编辑问题 提前判断 在给AI的需求的时候，我们要先让他复述一遍需求，然后再答复操作，这样可以做二次核对 缩小指令辐射范围 如图 使用Cursor的具体开发流程 如果你是程序员的话，希望Cursor帮你完成后续项目\n开启这个(indexing)功能，意味着你的文件是会被上传到cursor服务器进行分析的，如果你不想一些核心文件或无关文件被cursor索引，是可以将它们添加到这下面的“Ignore files”中的。\n你应该先让Cursor检索的你的项目，去做一个cursorignore文件\n然后做Codebase indexing下的Resvnc Index重新索引\n然后把所有的技术文档都录入到doc中以作备用\n然后再设置一个cursorrules文件，如果你不知道怎么写，可以问ai（最好是一条条写）\n如果后面写的东西有bug了，可以使用@git来看之前没有bug的版本，或者对于比较简单直接让composer做修改即可\n如果比较复杂就创建一个notepad，让他基于这个notepad里面的内容来例假问题\n这样以后这些notepad可以导出之后生成一个类似的doc文档，如果有一天再打开文档的时候，可以让ai快速理解\n当然记得及时归档，因为notepad只是Cursor的缓存\n白嫖 https://github.com/yeongpin/cursor-free-vip\n","date":"2025-02-23T00:00:00Z","permalink":"https://SweetGargamel.github.io/p/cursor-nova%E5%88%86%E4%BA%AB/","title":"Cursor-Nova分享"},{"content":"2P2E 初步实现图片转Excel功能 项目目标 2P2E（PDF\u0026amp;PIC to Excel） 项目背景\n有一种需求，不痛，能忍，频度也不一定高，但是恶心起来也很恶心\n那就是把上面的pdf和pic变成可编辑的excel表格的需求 ，思考AI时代，这件事可以不可以变成一个产品\n核心技术\n包括但不限于：\n图片自动改善（二值化、矩形矫正、散焦模糊处理等） OCR PDF去水印、解密、文字解析 模式识别（如表格区域识别、手写体识别等） 批量处理 工程需求\n做成产品，卖出去\n详细需求 1. 实现前后端分离 目前的程序有两大缺点：1. 使用命令行交互，对用户并不友好 2. python 稳定性较差，对环境要求高。鉴于此，我们应该让程序前后端分离：将目前的所有内容都归档至 server，将其包装成 API 接口在云端服务器运行，之后用其他稳定的语言（如 Rust、Qt 等）写一个 client，所有计算和请求都通过 API 完成而非本地计算，只对用户开放 client。同时这样也可以有更多丰富的交互功能，可以让用户方便地在中途手动或借助大模型调整数据集或中间结果。\n2. 对图片进行进一步预处理 预处理在 preprocess_pic.py 中完成，目前只有用户手动选定区域的功能。事实上遇到的图片可能有各种情况：拍屏、滤镜、模糊等，一方面可以让用户手动调整图片参数，另一方面希望在这里使用大模型自动调整图片参数，人工可以只做微调。\n还有一种特殊的预处理：手写文字。有时候用户会拍手写的表格，其中最难处理的就是手写文字了，大部分图片转表格的 API 都不能很好地处理它们。我的想法是在预处理阶段就把它们解决掉：用大模型找到所有手写文字，使用适用于手写文字的 OCR 模型识别成印刷体后替换回图片里，这样就能保证提供给程序主体的图片里永远只有印刷体。\n3. 支持批量处理 单张图片每个人都可以轻松提取出内容，批量的场景才是真正需要程序辅助的地方。我们需要支持批量读取数据并存储到一个数据库里进行问答。比如给出全班所有人的体检单图片，可以直接问出这个班有哪些人视力在 4.5 以上。给出一车库的发票的图片，可以直接算出总额等等。但这个过程有些困难，需要思考的点是：1. 数据量够大时肯定只调用一次大模型就处理好。对输入数据切片后进行分别处理，如何让大模型生成前后格式完全统一的表格，如何完成拼接？ 2. 有时候本身图片中的数据格式前后就不完全统一，（比如 90 分和优秀），这时候如何统一格式以方便统计？我觉得可能需要用户补充交换一些关于内容的描述以纠正并存储。\n要想完成这个任务，可能要修改的地方不止一处，请务必确保模块化且每个模块都在正确的文件里。\n4. 支持各种格式 我们还想支持一些其他格式，比如 .pdf 文件。实现 3 后这里的实现就简单多了，可以批量转成图片后再处理。同时，批量的数据集也应当允许出现图片、表格、pdf、数据库混杂的情况，必须要能正常处理。同时也要支持一个工作簿的多张工作表。\n5. 允许多模态的输出 有的时候我们想要处理整张表格（整理格式，提取部分列）而非得到一个统计结果，这时候我们应当能够正确地生成用户需要的数据库、表格等。\n6. 支持缓存 目前的预处理时间过长，处理过的图片再次运行程序进行对话需要再次处理实在不太友善，我们可以通过 MD5、SHA1 等哈希值判断该图片是否有处理过，如果有直接利用之前的缓存即可。\n7. 收集数据、训练自己的 OCR 模型 图片处理这块我可不想一直指望用 API 呀，明明有很多优秀的开源深度学习网络训练一下就能用了。选择合适的网络，前期先用 API 过渡并收集数据，后期训练我们自己的模型！\n8. 验证所有中间结果并修复 大模型是肯定会犯错的，更何况是自然语言大模型，而我们基本所有的交互都是通过 prompt 工程实现的，更不稳定了，一但链式调用的任何一个环节出错都会有严重后果。因此我们需要：\n实现一个 validate 的方法验证所有结果是否符合格式，目前我写好的太简单了，只能判断行数和列数，事实上合法性判断远不止这些。 实现一个 fix 方法，目前我的实现大家看源码就知道，只能处理简单的格式错误。事实上，这里是可以通过（和用户交互获得更多提示词）再次生成修复的。 9. 微调自己的 csv 生成 / 数据库生成模型 弃用提示词工程，这个好难 qwq\n目前实现的工作 调用豆包大模型的能力 这里使用了豆包的模型，来帮助我识别。考虑到使用大模型可以帮助我处理很多corner case ，比如它可以一定程度上进行推断，然后也可以做数据的清洗和筛选，但是美中不足的是对于海量的数据的时候他的运行速度真的太低下了（即使我充钱了也是这样的） 同时我是把图片提取和数据清戏分到两次不同的调用里面了，这样可能会效果更好一些（说白了就是拆解开了），但是就是这样会导致效率降低 注意后面你要本地跑要自己设置API-KEY和模型名字（这个模型的调用有点不一样，不是你简单创建一个API-KEY就行了的，还需要按照下面的文档一步步设置，比deepseek和kimi都要麻烦点） 但是这里用的SDK并不是OpenAi的，所以兼容性有点差 后面可以考虑给客户加一个自己需要输入的prompt的地方，这样可以客户按照自己的要求来输入prompt一并加到程序的prompt后面 但是因为我不知道刘舒然同学是怎么抓来的wps的东西的，所以不太清楚wps的效果 相关参考资料：\n快速入门-调用模型服务\u0026ndash;火山方舟大模型服务平台-火山引擎\n视觉理解\u0026ndash;火山方舟大模型服务平台-火山引擎\n使用Cursor编程 我发现使用AI的力量真的很强大，你只需要撰写合适的需求文档，然后对细节适当进行修改，你就可以快速写出来一个可以run的程序。从开始写到目前项目的我只用了3个小时时间（事实上里面很多代码我是看不懂的）\n我个人多少觉得前面详细需求的2并没有过多的必要？因为目前来看豆包对于手写的识别已经很好了（我试了试超过了deepseek）。只要不是手写的很难看的都可以识别/或者涂抹过多的地方都基本可以识别\n使用Cursor帮助我撰写了很详细的prompt了（可能这里真的是因为我用的豆包模型有一点点蠢吧，对于下面的图总是提取不出来CAC的字段，但是我用客户端界面的就可以\n测试数据和效果 图片部分 除了上面我说的第四个图名字CAC因为被涂抹了之外看不清楚，其他的都还比较准确（手写的字很丑，勿喷\n甚至对于我字段名字和我表格信息为同义词的时候他依然能够比较准确的返回出来\n效果如下\n我是clone刘舒然同学的仓库后，直接在他那个项目里面去新写的代码，所以Cursor里面实现的UI界面和裁切功能应该都是参考了刘舒然同学的代码\n代码部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 import tkinter as tk from tkinter import filedialog, ttk from PIL import Image, ImageTk import json import pandas as pd from typing import List, Dict import base64 import io from volcenginesdkarkruntime import Ark import os import datetime class CropWindow: def __init__(self, parent, image_path, callback): self.top = tk.Toplevel(parent) self.top.title(\u0026#34;裁切图片\u0026#34;) self.callback = callback # 加载原始图片 self.original_image = Image.open(image_path) # 计算显示尺寸 display_size = (800, 600) self.display_image = self.original_image.copy() self.display_image.thumbnail(display_size) # 计算缩放比例 self.scale_x = self.original_image.width / self.display_image.width self.scale_y = self.original_image.height / self.display_image.height # 创建画布 self.canvas = tk.Canvas(self.top, width=self.display_image.width, height=self.display_image.height) self.canvas.pack(expand=True) # 显示图片 self.photo = ImageTk.PhotoImage(self.display_image) self.canvas.create_image(0, 0, image=self.photo, anchor=tk.NW) # 裁切区域变量 self.start_x = None self.start_y = None self.rect = None self.crop_coords = None # 绑定鼠标事件 self.canvas.bind(\u0026#34;\u0026lt;ButtonPress-1\u0026gt;\u0026#34;, self.on_press) self.canvas.bind(\u0026#34;\u0026lt;B1-Motion\u0026gt;\u0026#34;, self.on_drag) self.canvas.bind(\u0026#34;\u0026lt;ButtonRelease-1\u0026gt;\u0026#34;, self.on_release) # 添加按钮 button_frame = ttk.Frame(self.top) button_frame.pack(pady=5) ttk.Button(button_frame, text=\u0026#34;确认裁切\u0026#34;, command=self.crop_and_close).pack(side=tk.LEFT, padx=5) ttk.Button(button_frame, text=\u0026#34;跳过裁切\u0026#34;, command=self.skip_crop).pack(side=tk.LEFT, padx=5) def on_press(self, event): \u0026#34;\u0026#34;\u0026#34;鼠标按下时的处理\u0026#34;\u0026#34;\u0026#34; self.start_x = event.x self.start_y = event.y # 如果已经有矩形，删除它 if self.rect: self.canvas.delete(self.rect) self.rect = None def on_drag(self, event): \u0026#34;\u0026#34;\u0026#34;鼠标拖动时的处理\u0026#34;\u0026#34;\u0026#34; if self.start_x is None: return # 如果已经有矩形，删除它 if self.rect: self.canvas.delete(self.rect) # 创建新矩形 self.rect = self.canvas.create_rectangle( self.start_x, self.start_y, event.x, event.y, outline=\u0026#39;red\u0026#39; ) def on_release(self, event): \u0026#34;\u0026#34;\u0026#34;鼠标释放时的处理\u0026#34;\u0026#34;\u0026#34; if self.start_x is None: return # 确保有一个有效的选择区域 x1 = min(self.start_x, event.x) y1 = min(self.start_y, event.y) x2 = max(self.start_x, event.x) y2 = max(self.start_y, event.y) # 保存裁切坐标（考虑缩放比例） self.crop_coords = ( int(x1 * self.scale_x), int(y1 * self.scale_y), int(x2 * self.scale_x), int(y2 * self.scale_y) ) def crop_and_close(self): \u0026#34;\u0026#34;\u0026#34;裁切图片并关闭窗口\u0026#34;\u0026#34;\u0026#34; if self.crop_coords: # 裁切图片 cropped_image = self.original_image.crop(self.crop_coords) # 调用回调函数 self.callback(cropped_image) self.top.destroy() def skip_crop(self): \u0026#34;\u0026#34;\u0026#34;跳过裁切\u0026#34;\u0026#34;\u0026#34; self.callback(self.original_image) self.top.destroy() class ImageProcessorApp: def __init__(self, root): self.root = root self.root.title(\u0026#34;图片表格提取器\u0026#34;) self.root.geometry(\u0026#34;800x600\u0026#34;) # 初始化API客户端 self.client = Ark(api_key=\u0026#39;\u0026#39;) #修改APIkey self.client.api_key = \u0026#34;1c477866-b675-423e-b205-3c285fb15925\u0026#34; # 存储选中的图片 self.images: List[Dict] = [] self.current_crop_index = 0 self.pending_images = [] # 存储提取字段和Excel导出路径 self.fields = [\u0026#34;姓名\u0026#34;, \u0026#34;车次\u0026#34;, \u0026#34;出发地\u0026#34;, \u0026#34;目的地\u0026#34;, \u0026#34;车票价格\u0026#34;] # 默认字段 self.excel_output_path = \u0026#34;\u0026#34; # 添加当前显示图片的索引 self.current_display_index = 0 self.setup_ui() def setup_ui(self): # 创建主框架 self.main_frame = ttk.Frame(self.root) self.main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10) # 创建水平方向的主面板分隔器 self.main_panel = ttk.PanedWindow(self.main_frame, orient=tk.HORIZONTAL) self.main_panel.pack(fill=tk.BOTH, expand=True) # 创建左侧面板（可伸缩） self.left_panel = ttk.PanedWindow(self.main_panel, orient=tk.HORIZONTAL) self.main_panel.add(self.left_panel, weight=4) # 左侧占比更大 # 创建左侧缩略图区域 self.thumbnail_frame = ttk.LabelFrame(self.left_panel, text=\u0026#34;已上传图片\u0026#34;) self.left_panel.add(self.thumbnail_frame, weight=1) # 创建缩略图滚动区域 self.thumb_canvas = tk.Canvas(self.thumbnail_frame, width=150) self.thumb_scrollbar = ttk.Scrollbar(self.thumbnail_frame, orient=tk.VERTICAL, command=self.thumb_canvas.yview) self.thumb_canvas.configure(yscrollcommand=self.thumb_scrollbar.set) self.thumb_scrollbar.pack(side=tk.RIGHT, fill=tk.Y) self.thumb_canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True) self.thumbnail_container = ttk.Frame(self.thumb_canvas) self.thumb_canvas.create_window((0, 0), window=self.thumbnail_container, anchor=tk.NW) # 创建中央图片显示区域 self.display_frame = ttk.Frame(self.left_panel) self.left_panel.add(self.display_frame, weight=3) # 添加图片导航按钮 nav_frame = ttk.Frame(self.display_frame) nav_frame.pack(fill=tk.X, pady=5) ttk.Button(nav_frame, text=\u0026#34;上一张\u0026#34;, command=self.prev_image).pack(side=tk.LEFT, padx=5) ttk.Button(nav_frame, text=\u0026#34;下一张\u0026#34;, command=self.next_image).pack(side=tk.LEFT, padx=5) ttk.Button(nav_frame, text=\u0026#34;选择图片\u0026#34;, command=self.select_images).pack(side=tk.LEFT, padx=5) ttk.Button(nav_frame, text=\u0026#34;裁剪图片\u0026#34;, command=self.crop_current_image).pack(side=tk.LEFT, padx=5) ttk.Button(nav_frame, text=\u0026#34;处理图片\u0026#34;, command=self.process_images).pack(side=tk.LEFT, padx=5) ttk.Button(nav_frame, text=\u0026#34;清空图片\u0026#34;, command=self.clear_images).pack(side=tk.LEFT, padx=5) # 创建主图片显示区域 self.main_image_label = ttk.Label(self.display_frame) self.main_image_label.pack(fill=tk.BOTH, expand=True) # 添加图片序号显示 self.image_counter_label = ttk.Label(self.display_frame, text=\u0026#34;\u0026#34;) self.image_counter_label.pack(pady=5) # 创建右侧设置区域 self.settings_frame = ttk.Frame(self.main_panel) self.main_panel.add(self.settings_frame, weight=1) # 右侧占比较小 # 字段设置区域 field_settings = ttk.LabelFrame(self.settings_frame, text=\u0026#34;字段设置\u0026#34;) field_settings.pack(fill=tk.X, pady=5, padx=5) ttk.Label(field_settings, text=\u0026#34;提取字段（一行一个）：\u0026#34;).pack(padx=5, pady=2) self.fields_text = tk.Text(field_settings, height=5, width=30) self.fields_text.pack(padx=5, pady=2) self.fields_text.insert(\u0026#39;1.0\u0026#39;, \u0026#34;\\n\u0026#34;.join(self.fields)) ttk.Button(field_settings, text=\u0026#34;更新字段\u0026#34;, command=self.update_fields).pack(padx=5, pady=5) # Excel输出路径设置 path_settings = ttk.LabelFrame(self.settings_frame, text=\u0026#34;导出设置\u0026#34;) path_settings.pack(fill=tk.X, pady=5, padx=5) ttk.Label(path_settings, text=\u0026#34;Excel导出路径：\u0026#34;).pack(padx=5, pady=2) self.path_var = tk.StringVar() ttk.Entry(path_settings, textvariable=self.path_var, width=30).pack(padx=5, pady=2) ttk.Button(path_settings, text=\u0026#34;选择路径\u0026#34;, command=self.select_output_path).pack(padx=5, pady=5) def clear_images(self): \u0026#34;\u0026#34;\u0026#34;清空所有已加载的图片\u0026#34;\u0026#34;\u0026#34; self.images.clear() self.current_display_index = 0 self.refresh_thumbnail_view() self.update_main_display() def refresh_thumbnail_view(self): \u0026#34;\u0026#34;\u0026#34;刷新左侧缩略图显示\u0026#34;\u0026#34;\u0026#34; # 清除现有缩略图 for widget in self.thumbnail_container.winfo_children(): widget.destroy() # 重新添加缩略图 for i, img_info in enumerate(self.images): frame = ttk.Frame(self.thumbnail_container) frame.pack(pady=5, padx=5) # 创建缩略图 thumb = img_info[\u0026#34;image\u0026#34;].copy() thumb.thumbnail((100, 100)) photo = ImageTk.PhotoImage(thumb) # 创建图片标签和删除按钮的容器 thumb_frame = ttk.Frame(frame) thumb_frame.pack() # 添加序号标签 ttk.Label(thumb_frame, text=f\u0026#34;{i + 1}/{len(self.images)}\u0026#34;).pack() label = ttk.Label(thumb_frame, image=photo) label.image = photo label.pack() # 添加删除按钮 ttk.Button(thumb_frame, text=\u0026#34;×\u0026#34;, width=2, command=lambda idx=i: self.remove_image(idx)).pack() # 绑定点击事件 label.bind(\u0026#39;\u0026lt;Button-1\u0026gt;\u0026#39;, lambda e, idx=i: self.show_image(idx)) # 更新滚动区域 self.thumbnail_container.update_idletasks() self.thumb_canvas.configure(scrollregion=self.thumb_canvas.bbox(\u0026#34;all\u0026#34;)) def remove_image(self, index): \u0026#34;\u0026#34;\u0026#34;删除指定索引的图片\u0026#34;\u0026#34;\u0026#34; if 0 \u0026lt;= index \u0026lt; len(self.images): self.images.pop(index) if self.current_display_index \u0026gt;= len(self.images): self.current_display_index = max(0, len(self.images) - 1) self.refresh_thumbnail_view() self.update_main_display() def show_image(self, index): \u0026#34;\u0026#34;\u0026#34;显示指定索引的图片\u0026#34;\u0026#34;\u0026#34; if 0 \u0026lt;= index \u0026lt; len(self.images): self.current_display_index = index self.update_main_display() def update_main_display(self): \u0026#34;\u0026#34;\u0026#34;更新主显示区域的图片\u0026#34;\u0026#34;\u0026#34; if not self.images: self.main_image_label.configure(image=\u0026#39;\u0026#39;) self.image_counter_label.configure(text=\u0026#34;\u0026#34;) return img = self.images[self.current_display_index][\u0026#34;image\u0026#34;].copy() # 调整图片大小以适应显示区域 display_size = (600, 400) img.thumbnail(display_size) photo = ImageTk.PhotoImage(img) self.main_image_label.configure(image=photo) self.main_image_label.image = photo # 更新图片序号显示 self.image_counter_label.configure( text=f\u0026#34;当前第 {self.current_display_index + 1} 张，共 {len(self.images)} 张\u0026#34; ) def prev_image(self): \u0026#34;\u0026#34;\u0026#34;显示上一张图片\u0026#34;\u0026#34;\u0026#34; if self.images: self.current_display_index = (self.current_display_index - 1) % len(self.images) self.update_main_display() def next_image(self): \u0026#34;\u0026#34;\u0026#34;显示下一张图片\u0026#34;\u0026#34;\u0026#34; if self.images: self.current_display_index = (self.current_display_index + 1) % len(self.images) self.update_main_display() def select_images(self): filepaths = filedialog.askopenfilenames( title=\u0026#34;选择图片\u0026#34;, filetypes=[(\u0026#34;Image files\u0026#34;, \u0026#34;*.png *.jpg *.jpeg *.gif *.bmp\u0026#34;)] ) if not filepaths: return # 加载新图片 for filepath in filepaths: try: image = Image.open(filepath) self.images.append({ \u0026#34;filepath\u0026#34;: filepath, \u0026#34;image\u0026#34;: image }) except Exception as e: tk.messagebox.showerror(\u0026#34;错误\u0026#34;, f\u0026#34;无法加载图片 {filepath}: {str(e)}\u0026#34;) # 刷新显示 self.refresh_thumbnail_view() if self.images: self.show_image(len(self.images) - 1) def update_fields(self): field_text = self.fields_text.get(\u0026#39;1.0\u0026#39;, tk.END) self.fields = [f.strip() for f in field_text.split(\u0026#39;\\n\u0026#39;) if f.strip()] tk.messagebox.showinfo(\u0026#34;成功\u0026#34;, \u0026#34;字段已更新！\u0026#34;) def select_output_path(self): folder_path = filedialog.askdirectory(title=\u0026#34;选择Excel导出目录\u0026#34;) if folder_path: self.excel_output_path = folder_path self.path_var.set(folder_path) def process_images(self): if not self.images: tk.messagebox.showwarning(\u0026#34;警告\u0026#34;, \u0026#34;请先选择图片！\u0026#34;) return if not self.excel_output_path: tk.messagebox.showwarning(\u0026#34;警告\u0026#34;, \u0026#34;请先选择Excel导出路径！\u0026#34;) return all_data = [] for img_info in self.images: try: # 将图片转换为PNG格式（确保格式兼容性） img = img_info[\u0026#39;image\u0026#39;] buffered = io.BytesIO() # 统一转换为PNG格式 if img.mode in (\u0026#39;RGBA\u0026#39;, \u0026#39;LA\u0026#39;) or (img.mode == \u0026#39;P\u0026#39; and \u0026#39;transparency\u0026#39; in img.info): # 如果图片带有透明通道，先转换为RGB img = img.convert(\u0026#39;RGB\u0026#39;) img.save(buffered, format=\u0026#34;PNG\u0026#34;) img_str = base64.b64encode(buffered.getvalue()).decode(\u0026#39;utf-8\u0026#39;) # 第一次提示词优化 prompt = ( f\u0026#34;请仔细分析这张图片，提取以下字段的信息并以JSON格式返回：{\u0026#39;, \u0026#39;.join(self.fields)}。\\n\u0026#34; \u0026#34;注意事项：\\n\u0026#34; \u0026#34;1. 图片中包含手写体文字，请特别注意：\\n\u0026#34; \u0026#34; - 仔细辨识每个手写字符，包括潦草字迹\\n\u0026#34; \u0026#34; - 注意辨识英文字母、数字和特殊符号\\n\u0026#34; \u0026#34; - 对于不确定的字符，尝试从上下文推断\\n\u0026#34; \u0026#34;2. 关于涂抹和修改的处理：\\n\u0026#34; \u0026#34; - 如有涂抹内容，优先识别涂抹处周围或上方的新增内容\\n\u0026#34; \u0026#34; - 对于部分涂抹但仍可见的内容，尝试识别可见部分\\n\u0026#34; \u0026#34; - 注意识别批注、更正或添加的内容\\n\u0026#34; \u0026#34;3. 特殊情况处理：\\n\u0026#34; \u0026#34; - 对于缩写或简写，尽可能还原完整内容\\n\u0026#34; \u0026#34; - 注意识别表格边缘或角落的信息\\n\u0026#34; \u0026#34; - 对于模糊不清的内容，根据上下文推断\\n\u0026#34; \u0026#34;4. 如果某字段信息确实无法识别或不存在，返回空字符串\\n\u0026#34; \u0026#34;5. 优先提取最新的、有效的信息，忽略已被明确删除的内容\u0026#34; ) messages = [ { \u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;text\u0026#34;: prompt }, { \u0026#34;type\u0026#34;: \u0026#34;image_url\u0026#34;, \u0026#34;image_url\u0026#34;: { \u0026#34;url\u0026#34;: f\u0026#34;data:image/png;base64,{img_str}\u0026#34; } } ] } ] # 发送请求 response = self.client.chat.completions.create( model=\u0026#34;ep-20250118110159-n2vsp\u0026#34;, messages=messages ) # 解析第一次响应 if response.choices and response.choices[0]: raw_result = json.loads(response.choices[0].message.content) # 修改数据整理的提示词 organize_prompt = ( \u0026#34;我需要你帮我整理以下数据到规范的格式。这些数据来自图片识别结果，需要被整理成独立的记录。\\n\u0026#34; \u0026#34;原始数据如下：\\n\u0026#34; f\u0026#34;{json.dumps(raw_result, ensure_ascii=False, indent=2)}\\n\\n\u0026#34; \u0026#34;请你将数据处理成列表格式，每个元素都是一个字典，对应一条完整的记录。\\n\u0026#34; \u0026#34;处理要求：\\n\u0026#34; \u0026#34;1. 数据拆分和整理：\\n\u0026#34; \u0026#34; - 如果任何字段中包含多个值，将其拆分成多个独立记录\\n\u0026#34; \u0026#34; - 确保拆分后的每条记录包含所有必要字段：\u0026#34; + f\u0026#34;{\u0026#39;, \u0026#39;.join(self.fields)}\\n\u0026#34; \u0026#34; - 保持各字段之间的对应关系\\n\u0026#34; \u0026#34;2. 特殊内容处理：\\n\u0026#34; \u0026#34; - 统一处理英文大小写（如缩写、代码等）\\n\u0026#34; \u0026#34; - 规范化数字格式（如价格、编号等）\\n\u0026#34; \u0026#34; - 处理可能的重复信息\\n\u0026#34; \u0026#34;3. 数据完整性：\\n\u0026#34; \u0026#34; - 返回JSON格式，确保每个字段都存在\\n\u0026#34; \u0026#34; - 对无法识别的信息使用空字符串\\n\u0026#34; \u0026#34; - 保持数据的一致性和完整性\\n\u0026#34; \u0026#34;4. 上下文关联：\\n\u0026#34; \u0026#34; - 利用上下文补充可能缺失的信息\\n\u0026#34; \u0026#34; - 确保关联字段之间的逻辑性\\n\u0026#34; \u0026#34; - 处理可能的交叉引用\\n\u0026#34; \u0026#34;5. 数据清理：\\n\u0026#34; \u0026#34; - 移除多余的空格和特殊字符\\n\u0026#34; \u0026#34; - 统一格式化字符串\\n\u0026#34; \u0026#34; - 确保数据的规范性\\n\u0026#34; \u0026#34;请直接返回JSON数组，数组中的每个元素都应该是包含所有必要字段的字典。不要包含任何其他解释文字。\u0026#34; ) # 发送第二次请求进行数据整理 organize_response = self.client.chat.completions.create( model=\u0026#34;ep-20250117235826-zpdh8\u0026#34;, messages=[ { \u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: organize_prompt } ] ) if organize_response.choices and organize_response.choices[0]: # 解析整理后的数据 organized_results = json.loads(organize_response.choices[0].message.content) all_data.extend(organized_results) # 使用extend而不是append print(f\u0026#34;处理完成图片：{img_info[\u0026#39;filepath\u0026#39;]}\u0026#34;) print(f\u0026#34;整理后的结果：{organized_results}\u0026#34;) except Exception as e: tk.messagebox.showerror(\u0026#34;错误\u0026#34;, f\u0026#34;处理图片时出错：{str(e)}\u0026#34;) continue if all_data: try: # 直接使用整理后的数据创建DataFrame df = pd.DataFrame(all_data) # 使用指定路径保存Excel timestamp = datetime.datetime.now().strftime(\u0026#34;%Y%m%d_%H%M%S\u0026#34;) output_file = os.path.join(self.excel_output_path, f\u0026#34;提取结果_{timestamp}.xlsx\u0026#34;) df.to_excel(output_file, index=False) tk.messagebox.showinfo(\u0026#34;成功\u0026#34;, f\u0026#34;数据已保存到：{output_file}\u0026#34;) except Exception as e: tk.messagebox.showerror(\u0026#34;错误\u0026#34;, f\u0026#34;保存Excel文件时出错：{str(e)}\u0026#34;) def crop_current_image(self): \u0026#34;\u0026#34;\u0026#34;裁剪当前显示的图片\u0026#34;\u0026#34;\u0026#34; if not self.images or self.current_display_index \u0026gt;= len(self.images): tk.messagebox.showwarning(\u0026#34;警告\u0026#34;, \u0026#34;没有可裁剪的图片！\u0026#34;) return img_info = self.images[self.current_display_index] CropWindow(self.root, img_info[\u0026#39;filepath\u0026#39;], lambda cropped: self.on_crop_complete(cropped, self.current_display_index)) def on_crop_complete(self, cropped_image, index): \u0026#34;\u0026#34;\u0026#34;处理裁剪完成的图片\u0026#34;\u0026#34;\u0026#34; if 0 \u0026lt;= index \u0026lt; len(self.images): self.images[index][\u0026#39;image\u0026#39;] = cropped_image self.refresh_thumbnail_view() self.update_main_display() def main(): root = tk.Tk() app = ImageProcessorApp(root) root.mainloop() if __name__ == \u0026#34;__main__\u0026#34;: main() ","date":"2025-01-13T00:00:00Z","permalink":"https://SweetGargamel.github.io/p/2p2epdfpic-to-excel/","title":"2P2E（PDF\u0026PIC to Excel）"},{"content":"读《飘》 一些个人感想 对她爱过的这两个男人，她谁都没有真正了解过，所以才都失去了他们。直到现在她才模模糊糊地意识到，如果她真正的了解过阿希里，她就绝不会爱上他；如果她真正了解过瑞特，她也就绝不会失去他了。\n从24年暑假我就开始有想法，到了大学以后要多读一些经典名著\n果然经典的名著总是会给人感染力的，从在塔拉庄园“风姿翩翩”的少女，到最后残酷无情、唯利是图甚至有些卑鄙的夫人，我没有想到十年内（甚至说不用十年的时间，仅仅是一场战争）就能够这么显著的改变了一个人的性格。\n一个人，活一世总是要有些盼头才能活下去的。否则一个人也就“失去了所有的力气和手段”。支持斯嘉丽的，一开始是“少男”们的追崇，在，后面则是为了谋生所必须的钱和利益。当然，还有她追求了十多年的阿希里。她为了她的目标，可以不择一切手段——可以去欺骗弗朗克，可以去压榨罪犯和黑人。她勇敢，她胆大，她精明能干，她无所顾忌；当然她也足够卑鄙，足够放浪，足够无情。就是这种近乎冷血的行为，让她获得了足够的财富、声誉和地位。\n但是转过头来到最后，实际上她失去了一切。\n这么长时间以来，我一直也在思考人生的价值和意义所在，也更在思考时代与个人的紧密关系。我们究竟是为了什么而活着，又究竟在追求着什么，我们的时代又会怎样无私的送来/无情的剥夺我们的所求所爱的一件件事物。\n因为某些事情，我可能对于“命运”二字格外相信。我可能有一点落入罗翔老师所说的“宿命论”的范畴。虽然我自认为努力会有成果，但是我可能更相信命运的安排。说句不好听的，如果不是上天给了我一副还算擅长文化知识学习的头脑，我又怎么能够现在来到NJU读书呢？所以，我现在可能更愿意相信上天赋予我的东西吧——得之我幸，不得我命。即便是许多时候别人的风光，背后可能是无数的苦痛与折磨，而我“又何羡乎”？\n我知道有些往事永远无法散去，那种痛苦可能要几年甚至十几年的时光的稀释。但是我不希望我和斯嘉丽一样，再为了某些虚无缥缈的东西而失去、错过所爱的人吧。我只希望自己能够快点承担起自己的责任，去陪她一起走过人生的春夏秋冬。\nGone with the wind\nGone with the wind\n就让往事随风飘去\nBy SweetGargamel\n","date":"2025-01-13T00:00:00Z","image":"https://SweetGargamel.github.io/p/%E8%AF%BB%E9%A3%98/cover_hu_6bbb063a480fe96a.png","permalink":"https://SweetGargamel.github.io/p/%E8%AF%BB%E9%A3%98/","title":"读《飘》"},{"content":"解析SICP-Proj4 EC 本文章请搭配NJU-SICP Project04 EC (Adopted from CS61A from Berkeley) 食用\nWritten By SweetGargamel\nIntroduction - proj04: Scheme\nDebugging Guide - proj04: Scheme\n原问题 Why current interpreter cannot properly process tail call? Consider such scheme code:\n1 2 3 4 5 6 (define (factor n acc) (if (= n 0) acc (factor (- n 1) (* acc n)))) (factor 10 1) The current evaluation process is:\n1 2 3 4 scheme_eval(`(factor 10 1)) ===\u0026gt; return scheme_eval(`(factor 9 10)) ===\u0026gt; return (return scheme_eval(`(factor 8 90))) ... The problem is python interpreter does not properly perform tail call.\nThere\u0026rsquo;re mainly three way to solve this problem:\ntransform the scheme interpreter to an non-recursive interpreter, i.e., eliminate all recursive call to scheme_eval. That can be accomplished by rewrite this interpreter to an CEK interpreter. (\u0026lsquo;C\u0026rsquo; means control, \u0026lsquo;E\u0026rsquo; means environment, \u0026lsquo;K\u0026rsquo; means continuation). See here and Chap. 5 of ESSENTIALS OF PROGRAMMING LANGUAGES. rewrite this interpreter to an trampolined interpreter. We use this approach. transform the source scheme code, e.g. Continuation-Passing Style transformation. The trampoline technique is the simplest one. So we use this approach.\nTrampoline The trampoline technique is a simple technique to perform proper tail call in a \u0026ldquo;bad\u0026rdquo; language (e.g. Python, C, C++, Java, \u0026hellip;).\nFor example, we can define a sum recursive function in python:\n1 2 3 4 5 def sum(n, acc): if n == 0: return acc else: return sum(n - 1, acc + n) And sum(10000, 0) will produce a StackOverflow error. Now we \u0026ldquo;trampoline\u0026rdquo; such function:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Unevaluated: def __init__(self, n, acc): self.n = n self.acc = acc def sum_tram(n, acc): if n == 0: return acc else: return Unevaluated(n - 1, acc + n) def sum(n, acc): # use do-while here is better, but Python does not support that res = sum_tram(n, acc) while isinstance(res, Unevaluated): res = sum_tram(res.n, res.acc) return res Now sum(10000, 0) will properly works. This can be generalized to transform all recursive functions to loops, see here. But the above form is enough for our problem.\nThe Tasks Complete the function optimize_tail_calls in scheme_eval_apply.py. It returns an alternative to scheme_eval that is properly tail recursive. That is, the interpreter will allow an unbounded number of active tail calls in constant space. It has a third argument tail that indicates whether the expression to be evaluated is in a tail context.\nThe Unevaluated class represents an expression that needs to be evaluated in an environment. When optimized_eval receives a non-atomic expression in a tail context, it returns an Unevaluated instance. Otherwise, it should repeatedly call original_scheme_eval until the result is a value, rather than an Unevaluated.\nA successful implementation will require changes to several other functions, including some functions that we provided for you. All expressions throughout your interpreter that are in a tail context should be evaluated by calling scheme_eval with True as the third argument (now called tail). Your goal is to determine which expressions are in a tail context throughout your code and change calls to scheme_eval as needed.\nOnce you finish, uncomment the following line in scheme_eval_apply.py to use your implementation:\nscheme_eval = optimize_tail_calls(scheme_eval)\n疑惑引出 问题 1 2 3 4 5 6 7 8 def optimize_tail_calls(original_scheme_eval): def optimized_eval(expr, env, tail=False): if tail and not scheme_symbolp(expr) and not self_evaluating(expr): return Unevaluated(expr,env) # BEGIN PROBLEM EC # END PROBLEM EC return optimized_eval 是的，很显然你会不会觉得，开始在运行第一行代码的时候，如果是尾递归的话就会直接返回一个Unevaluated的玩意，这程序不就该崩了吗？ 答案 1 2 3 4 5 6 7 8 9 10 11 def optimize_tail_calls(original_scheme_eval): def optimized_eval(expr, env, tail=False): if tail and not scheme_symbolp(expr) and not self_evaluating(expr): return Unevaluated(expr,env) # BEGIN PROBLEM EC res=original_scheme_eval(expr, env) while isinstance(res, Unevaluated): res = original_scheme_eval(res.expr, res.env) return res # END PROBLEM EC return optimized_eval 是的你看了答案会不会更觉得下面的代码根本就运行不到？ （当然除了该这些代码还应该按照助教的建议，把凡是尾递归的部分都给加一个tail=True的参数） 使用Vscode的Debug功能解析 怎么使用Debug 直接按照助教的提示修改.vscode/launch.json文件即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Python: Current File\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;scheme.py\u0026#34;, \u0026#34;args\u0026#34;:[ \u0026#34;-i\u0026#34;, \u0026#34;tests.scm\u0026#34; ], \u0026#34;console\u0026#34;: \u0026#34;integratedTerminal\u0026#34;, \u0026#34;justMyCode\u0026#34;: true, } ] } 你可以修改tests.scm里面的测试用例来测试，下面是我的例子 1 2 3 4 5 6 (define (factor n acc) (if (= n 0) acc (factor (- n 1) (* acc n)))) (factor 10 1) 当然别忘打断点了\nDebug，启动！ 点击Start Debugging\n然后你会发现左边出来这些东西，分别是你的VARIABLES、WATCH、CALL_STACK\nVARIABLES是当前的变量 WATCH可以添加自己想看的表达式或者变量的值 CALL_STACK看调用的堆栈 我们发现他停到了if这个语句停下来了\n现在解释器在干啥？ 我们发现左上角的expr的第一个sym是define，说明他正在进行do_define_form 怎么让解释器往下走？ 在最上面有几个按钮，分别是下面几个 Step Into 如果当前语句是一个call expression，他就会进入函数体让你看函数体内部是怎么执行的；否则和Step Over一样。 Step Over：不管是否是call expression直接当一条普通语句运行过去。 Step Out：跳出当前Frame（比如A里面调用了B函数，我现在通过Step Into进入了B所在的Frame,Step Out就直接回到A里面） 所以我们按Step Into，你会发现他跳过了上面的if语句；这是因为我们现在是在do_define_form，并不是尾递归操作，所以就调用原始的eval_call. 我们再次选择Step Into，发现： 这个部分就比较好理解了，他就是在做define的内容，我就不解释了。\n做完define form之后 按照解释器解释的规则，我们把factor绑定到对应的lambda函数之后，就会执行(factor 10 1) 那么他的的执行顺序就是（请你注意看左下角的CALL_STACK）\neval factor eval 10 eval 1 图略，类似上面 apply lambda 10 1 我们发现这些都不是尾递归；\n在这一步之后选择Step Into\n进入apply过程！ 你会发现apply后，他就在do_if_form。注意，在调用do_if_form的时候参数tail=True 这里继续选择Step into\n然后就到了最核心的部分，这里终于会有Unevaluated类产生了（下面都简写为un类） 这里你要思考，我的un类返回到哪里了？你点一下Step Into，发现这个东西是返回到了scheme_eval里面。\n那么他是在eval谁？你看左边的Variables，这会正在做do_define_form。 然后你就会发现他回到了最外层的apply的过程 诶你是不是发现，这里上面虽然最左边的tail是false,但是这里返回了un类。\n思路理顺 通过上面的分析，我们发现，实际上un类并不会”漏出去“，实际上他是通过好层的递归调用，在最外层的eval_call（eval的是函数的call-expression)拿到了最里层eval_call（这里是do_if_form）返回的un类，然后再循环往复的eval。\n反思总结 我和xsh和fhy同学都交流过，他们似乎都感觉最后这个un类会被返回到最外层，从而你最后的eval结果都是一个un类。说明这应该是许多同学的共同的问题 然而通过Debug的逐句调用，我们发现靠空想是不行的，需要深入的一行行把自己当编译器理解。Debug应该是我们要掌握的一门技术。 最后再次感谢助教、各位同学的帮助！\n","date":"2025-01-08T00:00:00Z","image":"https://SweetGargamel.github.io/p/%E8%A7%A3%E6%9E%90sicp-proj4-ec/CoverImg_hu_86cbf617a66360db.png","permalink":"https://SweetGargamel.github.io/p/%E8%A7%A3%E6%9E%90sicp-proj4-ec/","title":"解析SICP-Proj4 EC"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image ![[fbd3eea69cc016df702f2f87583a19e8_MD5.png]]\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://SweetGargamel.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://SweetGargamel.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://SweetGargamel.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://SweetGargamel.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://SweetGargamel.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://SweetGargamel.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://SweetGargamel.github.io/p/emoji-support/","title":"Emoji Support"}]